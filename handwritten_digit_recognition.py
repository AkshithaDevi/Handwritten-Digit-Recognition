{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5def0c00",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(60000, 28, 28) (60000,)\n",
      "x_train shape: (60000, 28, 28, 1)\n",
      "60000 train samples\n",
      "10000 test samples\n",
      "Epoch 1/10\n",
      "469/469 [==============================] - 96s 204ms/step - loss: 2.2680 - accuracy: 0.1699 - val_loss: 2.2305 - val_accuracy: 0.2918\n",
      "Epoch 2/10\n",
      "469/469 [==============================] - 94s 200ms/step - loss: 2.2049 - accuracy: 0.2732 - val_loss: 2.1541 - val_accuracy: 0.4487\n",
      "Epoch 3/10\n",
      "469/469 [==============================] - 94s 201ms/step - loss: 2.1267 - accuracy: 0.3798 - val_loss: 2.0527 - val_accuracy: 0.6142\n",
      "Epoch 4/10\n",
      "469/469 [==============================] - 94s 200ms/step - loss: 2.0177 - accuracy: 0.4833 - val_loss: 1.9131 - val_accuracy: 0.6944\n",
      "Epoch 5/10\n",
      "469/469 [==============================] - 93s 198ms/step - loss: 1.8710 - accuracy: 0.5628 - val_loss: 1.7279 - val_accuracy: 0.7396\n",
      "Epoch 6/10\n",
      "469/469 [==============================] - 94s 201ms/step - loss: 1.6847 - accuracy: 0.6130 - val_loss: 1.5010 - val_accuracy: 0.7665\n",
      "Epoch 7/10\n",
      "469/469 [==============================] - 94s 201ms/step - loss: 1.4781 - accuracy: 0.6509 - val_loss: 1.2608 - val_accuracy: 0.7901\n",
      "Epoch 8/10\n",
      "469/469 [==============================] - 94s 201ms/step - loss: 1.2806 - accuracy: 0.6776 - val_loss: 1.0497 - val_accuracy: 0.8071\n",
      "Epoch 9/10\n",
      "469/469 [==============================] - 93s 199ms/step - loss: 1.1195 - accuracy: 0.7022 - val_loss: 0.8881 - val_accuracy: 0.8222\n",
      "Epoch 10/10\n",
      "469/469 [==============================] - 93s 198ms/step - loss: 0.9969 - accuracy: 0.7221 - val_loss: 0.7720 - val_accuracy: 0.8336\n",
      "The model has successfully trained\n",
      "Saving the model as mnist.h5\n",
      "Test loss: 0.7720104455947876\n",
      "Test accuracy: 0.8335999846458435\n"
     ]
    }
   ],
   "source": [
    "# Import the libraries and load the dataset\n",
    "import keras\n",
    "from keras.datasets import mnist\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Dropout, Flatten\n",
    "from keras.layers import Conv2D, MaxPooling2D\n",
    "from keras import backend as K\n",
    "\n",
    "# the data, split between train and test sets\n",
    "(x_train, y_train), (x_test, y_test) = mnist.load_data()\n",
    "\n",
    "print(x_train.shape, y_train.shape)\n",
    "\n",
    "#Preprocess the data\n",
    "x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)\n",
    "x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)\n",
    "input_shape = (28, 28, 1)\n",
    "# Set the number of classes\n",
    "num_classes = 10\n",
    "\n",
    "# convert class vectors to binary class matrices\n",
    "y_train = keras.utils.to_categorical(y_train, num_classes)\n",
    "y_test = keras.utils.to_categorical(y_test, num_classes)\n",
    "\n",
    "x_train = x_train.astype('float32')\n",
    "x_test = x_test.astype('float32')\n",
    "x_train /= 255\n",
    "x_test /= 255\n",
    "print('x_train shape:', x_train.shape)\n",
    "print(x_train.shape[0], 'train samples')\n",
    "print(x_test.shape[0], 'test samples')\n",
    "\n",
    "#Create the model\n",
    "batch_size = 128\n",
    "num_classes = 10\n",
    "epochs = 10\n",
    "\n",
    "model = Sequential()\n",
    "model.add(Conv2D(32, kernel_size=(3, 3),activation='relu',input_shape=input_shape))\n",
    "model.add(Conv2D(64, (3, 3), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "model.add(Flatten())\n",
    "model.add(Dense(256, activation='relu'))\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(num_classes, activation='softmax'))\n",
    "\n",
    "model.compile(loss=keras.losses.categorical_crossentropy,optimizer=keras.optimizers.Adadelta(),metrics=['accuracy'])\n",
    "\n",
    "#Train the model\n",
    "hist = model.fit(x_train, y_train,batch_size=batch_size,epochs=epochs,verbose=1,validation_data=(x_test, y_test))\n",
    "print(\"The model has successfully trained\")\n",
    "\n",
    "model.save('mnist.h5')\n",
    "print(\"Saving the model as mnist.h5\")\n",
    "\n",
    "#Evaluate the model\n",
    "score = model.evaluate(x_test, y_test, verbose=0)\n",
    "print('Test loss:', score[0])\n",
    "print('Test accuracy:', score[1])\n",
    "\n",
    "#Create GUI to predict digits\n",
    "from keras.models import load_model\n",
    "from tkinter import *\n",
    "import tkinter as tk\n",
    "import win32gui\n",
    "from PIL import ImageGrab, Image\n",
    "import numpy as np\n",
    "\n",
    "model = load_model('mnist.h5')\n",
    "\n",
    "def predict_digit(img):\n",
    "    # Resize image to 28x28 pixels\n",
    "    img = img.resize((28, 28))\n",
    "    # Convert RGB to grayscale\n",
    "    img = img.convert('L')\n",
    "    img = np.array(img)\n",
    "    # Reshaping to support the model input\n",
    "    img = img.reshape(1, 28, 28, 1)\n",
    "    # Normalize the pixel values\n",
    "    img = img.astype('float32') / 255.0\n",
    "    # Predict the class\n",
    "    res = model.predict(img)[0]\n",
    "    return np.argmax(res), max(res)\n",
    "\n",
    "\n",
    "class App(tk.Tk):\n",
    "    def __init__(self):\n",
    "        tk.Tk.__init__(self)\n",
    "\n",
    "        self.x = self.y = 0\n",
    "\n",
    "        # Creating elements\n",
    "        self.canvas = tk.Canvas(self, width=300, height=300, bg = \"white\", cursor=\"cross\")\n",
    "        self.label = tk.Label(self, text=\"Thinking..\", font=(\"Helvetica\", 48))\n",
    "        self.classify_btn = tk.Button(self, text = \"Recognise\", command =         self.classify_handwriting) \n",
    "        self.button_clear = tk.Button(self, text = \"Clear\", command = self.clear_all)\n",
    "\n",
    "        # Grid structure\n",
    "        self.canvas.grid(row=0, column=0, pady=2, sticky=W, )\n",
    "        self.label.grid(row=0, column=1,pady=2, padx=2)\n",
    "        self.classify_btn.grid(row=1, column=1, pady=2, padx=2)\n",
    "        self.button_clear.grid(row=1, column=0, pady=2)\n",
    "\n",
    "        #self.canvas.bind(\"<Motion>\", self.start_pos)\n",
    "        self.canvas.bind(\"<B1-Motion>\", self.draw_lines)\n",
    "\n",
    "    def clear_all(self):\n",
    "        self.canvas.delete(\"all\")\n",
    "\n",
    "    def classify_handwriting(self):\n",
    "        HWND = self.canvas.winfo_id() # get the handle of the canvas\n",
    "        rect = win32gui.GetWindowRect(HWND) # get the coordinate of the canvas\n",
    "        im = ImageGrab.grab(rect)\n",
    "\n",
    "        digit, acc = predict_digit(im)\n",
    "        self.label.configure(text= str(digit)+', '+ str(int(acc*100))+'%')\n",
    "\n",
    "    def draw_lines(self, event):\n",
    "        self.x = event.x\n",
    "        self.y = event.y\n",
    "        r=8\n",
    "        self.canvas.create_oval(self.x-r, self.y-r, self.x + r, self.y + r, fill='black')\n",
    "\n",
    "app = App()\n",
    "mainloop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "88be9628",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
